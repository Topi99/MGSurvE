'''Operators to calculate fitness and perform operations to search through optimization space.

'''

#!/usr/bin/env python
# -*- coding: utf-8 -*-
import math
import operator
import random
from abc import ABC
from os import path
from typing import List, Union, Optional, Tuple, Any, Dict, Callable

import numpy as np
import pandas as pd
import numpy.random as rand
from deap import base, creator, algorithms, tools, benchmarks

from .landscape import Landscape

###############################################################################
# Fitness function
###############################################################################
def reshapeInCanonicalForm(tau, sitesN, trapsN):
    """ Reshapes a migration matrix into canonical form (deprecated).
    
    Parameters:
        tau (numpy array): Traps migration matrix.
        sitesN (int): Number of sites.
        trapsN (int): Number of traps.

    Returns:
        (numpy array): Reshaped matrix in canonical form.
    """
    canO = list(range(sitesN, sitesN+trapsN))+list(range(0, sitesN))
    tauCan = np.asarray([[tau[i][j] for j in canO] for i in canO])
    return tauCan


def getMarkovAbsorbing(tauCan, trapsN):
    """ Get Markov's absorbing states (deprecated).
    
    Parameters:
        tauCan (numpy array): Traps migration matrix in canonical form.
        trapsN (int): Number of traps.

    Returns:
        (numpy array): Time to fall into absorbing states from anywhere in landscape.
    """
    A = tauCan[trapsN:, :trapsN]
    B = tauCan[trapsN:, trapsN:]
    F = np.linalg.inv(np.subtract(np.identity(B.shape[0]), B))
    return F


def getFundamentalMatrix(tau, sitesN, trapsN):
    """ Get Markov's fundamental matrix.
    
    Equivalent to using reshapeInCanonicalForm and getMarkovAbsorbing (which
        should be deprecated).

    Parameters:
        tau (numpy array): Traps migration matrix in canonical form.
        sitesN (int): Number of sites.
        trapsN (int): Number of traps.

    Returns:
        (numpy array): Time to fall into absorbing states from anywhere in landscape.
    """
    Q = tau[:sitesN, :sitesN]
    R = tau[:sitesN, -trapsN:]
    I = np.identity(Q.shape[0])
    F = np.linalg.inv(np.subtract(I, Q))
    return F


def getFundamentalFitness(
        fundamentalMatrix,
        fitFuns={'outer': np.mean, 'inner': np.max}
    ):
    """ Get fitness from Markov's fundamental matrix.

    Parameters:
        fundamentalMatrix (numpy array): Markov's fundamental matrix (calcFundamentalMatrix)
        fitFuns (dict): Dictionary containing the inner (row) and outer (col) operations for the fundamental matrix.

    Returns:
        (float): Summarized fitness function for the fundamental matrix.
    """
    daysInSites = np.apply_along_axis(fitFuns['inner'], 1, fundamentalMatrix)
    daysTillTrapped = fitFuns['outer'](daysInSites)
    return daysTillTrapped


###############################################################################
# GA (Basic)
###############################################################################
def initChromosome(trapsCoords, fixedTrapsMask, coordsRange):
    """ Generates a random uniform chromosome for GA optimization.
    
    Parameters:
        trapsNum (int): Number of traps to lay down in the landscape.
        xRan (tuple of tuples of floats): XY Range for the coordinates.
    Returns:
        (list): List of xy coordinates for the traps' positions.
    """
    (xRan, yRan) = coordsRange
    trapsNum = trapsCoords.shape[0]
    chromosome = trapsCoords.flatten()
    allele = 0
    for _ in range(trapsNum):
        if fixedTrapsMask[allele]:
            chromosome[allele+0] = np.random.uniform(xRan[0], xRan[1], 1)[0]
            chromosome[allele+1] = np.random.uniform(yRan[0], yRan[1], 1)[0]
        allele = allele + 2
    # xCoords = np.random.uniform(xRan[0], xRan[1], trapsNum)
    # yCoords = np.random.uniform(yRan[0], yRan[1], trapsNum)
    # chromosome = [val for pair in zip(xCoords, yCoords) for val in pair]
    return chromosome


def genFixedTrapsMask(trapsFixed, dims=2):
    """ Creates a mask for the fixed traps (non-movable).
    
    Parameters:
        trapsFixed (bool numpy array): Boolean array with the traps that are not movable (lnd.trapsFixed).
        dims (int): Unused for now, but it's the number of dimensions for the landscape.

    Returns:
        (numpy array): Mask of the elements that can be moved in the GA operations.
    """
    dups = [list([not(i)])*dims for i in trapsFixed]
    dupsVct = [item for sublist in dups for item in sublist]
    return np.asarray(dupsVct)


def mutateChromosome(
        chromosome, fixedTrapsMask,
        randFun=rand.normal,
        randArgs={'loc': 0, 'scale': 0.1},
        indpb=0.5
    ):
    """ Mutates a chromosome with a probability distribution based on the mutation mask (in place).
    
    Parameters:
        chromosome (floats numpy array): GA's float chromosome generated by initChromosome.
        fxdTrpsMsk (bool numpy array): Array of bools that define which alleles can be mutated (1).
        randFun (function): Probability function for the mutation operation.
        randArgs (dict): Arguments to control the shape of the probability function.
        indpb (float): Independent probability to mutate each allele.

    Returns:
        (numpy array list): Selectively-mutated chromosome.
    """
    cLen = len(chromosome)
    randDraw = randFun(size=cLen, **randArgs)
    randMsk = randDraw*fixedTrapsMask
    for i in range(len(chromosome)):
        if (random.random() < indpb) and (fixedTrapsMask[i]):
            chromosome[i] = chromosome[i] + randMsk[i]
    return (chromosome, )


def mutateChromosomeAsymmetric(
        chromosome, fixedTrapsMask,
        randFun=rand.normal,
        randArgs={
            'x': {'loc': 0, 'scale': 0.1},
            'y': {'loc': 0, 'scale': 0.1}
        },
        indpb=0.5
    ):
    """ Mutates a chromosome with a probability distribution based on the mutation mask with different probabilities for XY elements (in place).
    
    Parameters:
        chromosome (floats numpy array): GA's float chromosome generated by initChromosome.
        fxdTrpsMsk (bool numpy array): Array of bools that define which alleles can be mutated (1).
        randFun (function): Probability function for the mutation operation.
        randArgs (dict): Arguments to control the shape of the probability function ('x' and 'y' entries).
        indpb (float): Independent probability to mutate each allele.

    Returns:
        (numpy array list): Selectively-mutated chromosome.
    """
    cLen=len(chromosome)
    # Draw mutations for XY chromosomes ---------------------------------------
    randDrawX = randFun(size=int(cLen/2), **randArgs['x'])
    randDrawY = randFun(size=int(cLen/2), **randArgs['y'])
    # Interweave XY mutations -------------------------------------------------
    randDraw = np.empty((cLen,))
    randDraw[0::2] = randDrawX
    randDraw[1::2] = randDrawY
    # Mask and return results -------------------------------------------------
    randMsk = randDraw*fixedTrapsMask
    for i in range(len(chromosome)):
        if (random.random() < indpb) and (fixedTrapsMask[i]):
            chromosome[i] = chromosome[i] + randMsk[i]
    return (chromosome, )


def cxBlend(
        ind1, ind2,
        fixedTrapsMask,
        alpha=.5
    ):
    """ Mates two chromosomes by "blend" based on the provided mask (in place).
    
    This implementation is similar to DEAP's cxBlend (https://deap.readthedocs.io/en/master/api/tools.html#deap.tools.cxBlend). 
    Follow this link for the original code: https://github.com/DEAP/deap/blob/master/deap/tools/crossover.py

    Parameters:
        ind1 (floats numpy array): GA's float chromosome generated by initChromosome.
        ind2 (floats numpy array): GA's float chromosome generated by initChromosome.
        fxdTrpsMsk (bool numpy array): Array of bools that define which alleles can be mutated (1).
        alpha (float): weight for each of the chromosomes.

    Returns:
        (list of chromosomes): Mated individuals.
    """
    (offA, offB) = (ind1[:], ind2[:])
    for i, (x1, x2) in enumerate(zip(ind1, ind2)):
        if fixedTrapsMask[i]:
            gamma = (1. + 2. * alpha) * random.random() - alpha
            offA[i] = (1. - gamma) * x1 + gamma * x2
            offB[i] = gamma * x1 + (1. - gamma) * x2
    (ind1[:], ind2[:]) = (offA[:], offB[:])
    return (ind1, ind2)


###############################################################################
# GA (Extended)
###############################################################################


###############################################################################
# Fitness Functions
###############################################################################
def getDaysTillTrapped(
        landscape,
        fitFuns={'outer': np.mean, 'inner': np.max}
    ):
    """Gets the number of timesteps until a walker falls into a trap.

    Parameters:
        landscape (object): Landscape object to use for the analysis.
        fitFuns (dict): Dictionary with the outer (row) and inner (col) functions to use on the matrix.

    Returns:
        (float): Number of days for mosquitoes to fall into traps given the fitFuns.
    """
    funMat = getFundamentalMatrix(
        landscape.trapsMigration, landscape.pointNumber, landscape.trapsNumber
    )
    daysTillTrapped = getFundamentalFitness(funMat, fitFuns=fitFuns)
    return daysTillTrapped


def calcFitness(
        chromosome,
        landscape=None,
        optimFunction=getDaysTillTrapped,
        optimFunctionArgs={'outer': np.mean, 'inner': np.max},
        dims=2,
        clipValue=1000
    ):
    """Calculates the fitness function of the landscape given a chromosome (in place, so not thread-safe).

    Parameters:
        chromosome (floats numpy array): GA's float chromosome generated by initChromosome.
        landscape (object): Landscape object to use for the analysis.
        optimFunction (function): Function that turns a matrix into a fitness value.
        optimFunctionArgs (dict): Dictionary with the outer (row) and inner (col) functions to use on the matrix.

    Returns:
        (tuple of floats): Landscape's fitness function.
    """
    candidateTraps = np.reshape(chromosome, (-1, dims))
    landscape.updateTrapsCoords(candidateTraps)
    fit = optimFunction(landscape, fitFuns=optimFunctionArgs)
    return (float(abs(fit)), )


def calcSexFitness(
        chromosome,
        landscapeMale=None, landscapeFemale=None,
        weightMale=1, weightFemale=1,
        optimFunction=getDaysTillTrapped,
        optimFunctionArgs={'outer': np.mean, 'inner': np.max},
        dims=2
    ):
    """Calculates the fitness function of a Male/Female set of landscapes with a weighted sum of the time-to catch between them.

    Parameters:
        chromosome (floats numpy array): GA's float chromosome generated by initChromosome.
        landscapeMale (object): Male landscape object to use for the analysis.
        landscapeFemale (object): Female landscape object to use for the analysis.
        weightMale (float): Preference on catching males over females.
        weightFemale (float): Preference on catching females over males.
        optimFunction (function): Function that turns a matrix into a fitness value.
        optimFunctionArgs (dict): Dictionary with the outer (row) and inner (col) functions to use on the matrix.

    Returns:
        (tuple of floats): Landscape's fitness function.
    """
    candidateTraps = np.reshape(chromosome, (-1, dims))
    landscapeMale.updateTrapsCoords(candidateTraps)
    landscapeFemale.updateTrapsCoords(candidateTraps)
    fit = [
        abs(optimFunction(lnd, fitFuns=optimFunctionArgs)) for lnd in
        (landscapeMale, landscapeFemale)
    ]
    fitVal = (fit[0]*weightMale+fit[1]*weightFemale)/(2*(weightMale+weightFemale))
    return (fitVal, )

###############################################################################
# Logging results
###############################################################################
def exportLog(
        logbook,
        outPath,
        filename
    ):
    """Dumps a dataframe with the report of the GA's history.

    Parameters:
        logbook (object): DEAP GA object.
        outPath (path): Path where the file will be exported.
        F_NAME (string): Filenamme (without extension).

    """
    if not isinstance(logbook, pd.DataFrame):
        log = pd.DataFrame(logbook)
    else:
        log = logbook
    log.to_csv(path.join(outPath, filename)+'.csv', index=False)


def importLog(
        inPath,
        filename
    ):
    """Gets the number of timesteps until a walker falls into a trap.

    Parameters:
        LOG_PTH (path): Path where the file is stored.
        F_NAME (dict): Filename with extension.

    Returns:
        (pandas dataframe): GA optimization log.
    """
    df = pd.read_csv(path.join(inPath, filename+'.csv'))
    return df


###############################################################################
# GA Wrapper
###############################################################################
def optimizeTrapsGA(
        landscape,
        generations=1000,
        bbox='auto',pop_size='auto',
        mating_params={'mate': .3, 'cxpb': 0.5},
        mutation_params={'mean': 0, 'sd': 100, 'mutpb': .4, 'ipb': .5},
        selection_params={'tSize': 3},
        optimFunction=getDaysTillTrapped,
        fitFuns={'outer': np.mean, 'inner': np.max},
        verbose=True
    ):
    """Optimizes the traps' positions using a simple GA algorithm.

    Args:
        landscape (object): Landscape object to use for the analysis.
        generations (int, optional): Number of generations to run in the GA. Defaults to 1000.
        bbox (tuple, optional): If not 'auto', tuple with the landscape's bounding box for mutation operations. Defaults to 'auto'.
        pop_size (str, optional): If not 'auto', size of the chromosome population size in the GA. Defaults to 'auto'.
        mating_params (dict, optional): Mating probability ('mate') and crossover blending rate ('cxpb') for mating operations. Defaults to {'mate': .3, 'cxpb': 0.5}.
        mutation_params (dict, optional): Gaussian mean ('mean') and deviation ('sd') for mutation operations, as well as independent allele mutation probability ('ipb'). Defaults to {'mean': 0, 'sd': 100, 'mutpb': .4, 'ipb': .5}.
        selection_params (dict, optional): Tournament size for the selection algorithm. Defaults to {'tSize': 3}.
        optimFunction (function, optional): Fitness function to be used upon the movement matrices. Defaults to getDaysTillTrapped.
        fitFuns (dict, optional): Fitness matrix reduction statistics (inner applied first, and outter applied to the result). Defaults to {'outer': np.mean, 'inner': np.max}.
        verbose (bool, optional): Verbosity on the optimization. Defaults to True.

    Returns:
        (object, dataframe): Returns the landscape and logbook for the optimization.
    """
    if bbox == 'auto':
        bbox = landscape.getBoundingBox()
    # GA parameters -----------------------------------------------------------
    if pop_size == 'auto':
        pop_size = int(10*(landscape.trapsNumber*1.25))
    if mating_params == 'auto':
        mating_params = {'mate': .3, 'cxpb': 0.5}
    if mutation_params == 'auto':
        mutation_params = {
            'mean': 0, 'sd': max([i[1]-i[0] for i in bbox])/2.5,
            'mutpb': .4, 'ipb': .5
        }
    if selection_params == 'auto':
        selection_params = {'tSize': 3}
    trapsMask = genFixedTrapsMask(landscape.trapsFixed)
    ###########################################################################
    # Register GA Functions to DEAP
    ###########################################################################
    # Cost function to minimize -----------------------------------------------
    toolbox = base.Toolbox()
    creator.create("FitnessMin", base.Fitness, weights=(-1.0, ))
    creator.create("Individual", list, fitness=creator.FitnessMin)
    # Creators ----------------------------------------------------------------
    toolbox.register(
        "initChromosome", initChromosome,
        trapsCoords=landscape.trapsCoords,
        fixedTrapsMask=trapsMask,
        coordsRange=bbox
    )
    toolbox.register(
        "individualCreator", tools.initIterate,
        creator.Individual, toolbox.initChromosome
    )
    toolbox.register(
        "populationCreator", tools.initRepeat,
        list, toolbox.individualCreator
    )
    # Mating and mutation operators -------------------------------------------
    toolbox.register(
        "mate", cxBlend,
        fixedTrapsMask=trapsMask,
        alpha=mating_params['mate']
    )
    toolbox.register(
        "mutate", mutateChromosome,
        fixedTrapsMask=trapsMask,
        randArgs={'loc': mutation_params['mean'], 'scale': mutation_params['sd']},
        indpb=mutation_params['ipb']
    )
    # Select and evaluate -----------------------------------------------------
    toolbox.register(
        "select", tools.selTournament,
        tournsize=selection_params['tSize']
    )
    toolbox.register(
        "evaluate", calcFitness,
        landscape=landscape,
        optimFunction=optimFunction,
        optimFunctionArgs=fitFuns
    )
    ###########################################################################
    # Registering GA stats
    ###########################################################################
    pop = toolbox.populationCreator(n=pop_size)
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("min", np.min)
    stats.register("avg", np.mean)
    stats.register("max", np.max)
    stats.register(
        "best", lambda fitnessValues: fitnessValues.index(min(fitnessValues))
    )
    stats.register(
        "traps", lambda fitnessValues: pop[fitnessValues.index(min(fitnessValues))]
    )
    ###########################################################################
    # Optimization Cycle
    ###########################################################################
    (pop, logbook) = algorithms.eaSimple(
        pop, toolbox, ngen=generations,
        cxpb=mating_params['cxpb'], mutpb=mutation_params['mutpb'],
        stats=stats, halloffame=hof, verbose=verbose
    )
    ###############################################################################
    # Get and Export Results
    ############################################################################### 
    bestChromosome = hof[0]
    bestTraps = np.reshape(bestChromosome, (-1, 2))
    landscape.updateTrapsCoords(bestTraps)
    logDF = pd.DataFrame(logbook)
    return (landscape, logDF)


def optimizeTwoSexesTrapsGA(
        landscapeMale, landscapeFemale, sexWeights={'M': .5, 'F': .5},
        generations=1000,
        bbox='auto', pop_size='auto',
        mating_params={'mate': .3, 'cxpb': 0.5},
        mutation_params={'mean': 0, 'sd': 100, 'mutpb': .4, 'ipb': .5},
        selection_params={'tSize': 3},
        optimFunction=getDaysTillTrapped,
        fitFuns={'outer': np.mean, 'inner': np.max},
        verbose=True
    ):
    """Optimizes the traps' positions using a simple GA algorithm for two-sexes kernels.

    Args:
        landscapeMale (object): Male landscape object to use for the analysis.
        landscapeFemale (object): Female landscape object to use for the analysis.
        sexWeights (dictionary): Male-to-Female priority dictionary.
        generations (int, optional): Number of generations to run in the GA. Defaults to 1000.
        bbox (tuple, optional): If not 'auto', tuple with the landscape's bounding box for mutation operations. Defaults to 'auto'.
        pop_size (str, optional): If not 'auto', size of the chromosome population size in the GA. Defaults to 'auto'.
        mating_params (dict, optional): Mating probability ('mate') and crossover blending rate ('cxpb') for mating operations. Defaults to {'mate': .3, 'cxpb': 0.5}.
        mutation_params (dict, optional): Gaussian mean ('mean') and deviation ('sd') for mutation operations, as well as independent allele mutation probability ('ipb'). Defaults to {'mean': 0, 'sd': 100, 'mutpb': .4, 'ipb': .5}.
        selection_params (dict, optional): Tournament size for the selection algorithm. Defaults to {'tSize': 3}.
        optimFunction (function, optional): Fitness function to be used upon the movement matrices. Defaults to getDaysTillTrapped.
        fitFuns (dict, optional): Fitness matrix reduction statistics (inner applied first, and outter applied to the result). Defaults to {'outer': np.mean, 'inner': np.max}.
        verbose (bool, optional): Verbosity on the optimization. Defaults to True.

    Returns:
        (object, dataframe): Returns the landscape and logbook for the optimization.
    """
    if bbox == 'auto':
        bbox = landscapeMale.getBoundingBox()
    # GA parameters -----------------------------------------------------------
    if pop_size == 'auto':
        pop_size = int(10*(landscapeMale.trapsNumber*1.25))
    if mating_params == 'auto':
        mating_params = {'mate': .3, 'cxpb': 0.5}
    if mutation_params == 'auto':
        mutation_params = {
            'mean': 0, 'sd': max([i[1]-i[0] for i in bbox])/2.5,
            'mutpb': .4, 'ipb': .5
        }
    if selection_params == 'auto':
        selection_params = {'tSize': 3}
    trapsMask = genFixedTrapsMask(landscapeMale.trapsFixed)
    ###########################################################################
    # Register GA Functions to DEAP
    ###########################################################################
    # Cost function to minimize -----------------------------------------------
    toolbox = base.Toolbox()
    creator.create("FitnessMin", base.Fitness, weights=(-1.0, ))
    creator.create("Individual", list, fitness=creator.FitnessMin)
    # Creators ----------------------------------------------------------------
    toolbox.register(
        "initChromosome", initChromosome,
        trapsCoords=landscapeMale.trapsCoords,
        fixedTrapsMask=trapsMask,
        coordsRange=bbox
    )
    toolbox.register(
        "individualCreator", tools.initIterate,
        creator.Individual, toolbox.initChromosome
    )
    toolbox.register(
        "populationCreator", tools.initRepeat,
        list, toolbox.individualCreator
    )
    # Mating and mutation operators -------------------------------------------
    toolbox.register(
        "mate", cxBlend,
        fixedTrapsMask=trapsMask,
        alpha=mating_params['mate']
    )
    toolbox.register(
        "mutate", mutateChromosome,
        fixedTrapsMask=trapsMask,
        randArgs={'loc': mutation_params['mean'], 'scale': mutation_params['sd']},
        indpb=mutation_params['ipb']
    )
    # Select and evaluate -----------------------------------------------------
    toolbox.register(
        "select", tools.selTournament,
        tournsize=selection_params['tSize']
    )
    toolbox.register("evaluate",
        calcSexFitness,
        landscapeMale=landscapeMale,landscapeFemale=landscapeFemale,
        weightMale=sexWeights['M'], weightFemale=sexWeights['F'],
        optimFunction=optimFunction,
        optimFunctionArgs=fitFuns
    )
    ###########################################################################
    # Registering GA stats
    ###########################################################################
    pop = toolbox.populationCreator(n=pop_size)
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("min", np.min)
    stats.register("avg", np.mean)
    stats.register("max", np.max)
    stats.register(
        "best", lambda fitnessValues: fitnessValues.index(min(fitnessValues))
    )
    stats.register(
        "traps", lambda fitnessValues: pop[fitnessValues.index(min(fitnessValues))]
    )
    ###########################################################################
    # Optimization Cycle
    ###########################################################################
    (pop, logbook) = algorithms.eaSimple(
        pop, toolbox, ngen=generations,
        cxpb=mating_params['cxpb'], mutpb=mutation_params['mutpb'],
        stats=stats, halloffame=hof, verbose=verbose
    )
    ###############################################################################
    # Get and Export Results
    ############################################################################### 
    bestChromosome = hof[0]
    bestTraps = np.reshape(bestChromosome, (-1, 2))
    landscapeMale.updateTrapsCoords(bestTraps)
    landscapeFemale.updateTrapsCoords(bestTraps)
    logDF = pd.DataFrame(logbook)
    return ((landscapeMale, landscapeFemale), logDF)


class ParticleProps(ABC):
    speed: List[float]
    fitness: base.Fitness
    speed_min: int
    speed_max: int
    best: "Particle"


Particle = Union[List[float], ParticleProps]


def optimize_traps_pso(
    landscape: Landscape,
    generations: int = 1000,
    bbox: Tuple[Tuple[float, float], Tuple[float, float]] = None,
    pop_size: int = None,
    mating_params: Dict[str, float] = None,
    mutation_params: Dict[str, float] = None,
    selection_params: Dict[str, float] = None,
    optim_function: Callable[
        [Landscape, Dict[str, Any]], float
    ] = getDaysTillTrapped,
    fit_funcs: Dict[str, float] = None,
    verbose: bool = True,
) -> Tuple[Landscape, pd.DataFrame]:
    """Obtains the optimal position for a given set of traps

    Returns:
        None
    """

    mating_params = mating_params or {'mate': .3, 'cxpb': 0.5}
    mutation_params = mutation_params or {
        'mean': 0, 'sd': 100, 'mutpb': .4, 'ipb': .5
    }
    selection_params = selection_params or {'tSize': 3}
    fit_funcs = fit_funcs or {'outer': np.mean, 'inner': np.max}
    bbox = bbox or landscape.getBoundingBox()
    pop_size = pop_size or int(10 * (landscape.trapsNumber * 1.25))

    def generate_particle(
        size: int,
        position_min: int,
        position_max: int,
        speed_min: int,
        speed_max: int
    ) -> Particle:
        """Initializes a new Particle

        Args:
            size: number of attributes for the particle
            position_min: minimum position of a particle
            position_max: maximum position of a particle
            speed_min: minimum speed of a particle
            speed_max: maximum speed of a particle

        Returns:
            A new Particle
        """
        particle: Particle = creator.Particle(
            (random.uniform(position_min, position_max) for _ in range(size)),
        )
        particle.speed = [
            random.uniform(speed_min, speed_max) for _ in range(size)
        ]
        particle.speed_max = speed_max
        particle.speed_min = speed_min

        return particle

    def update_particle(
        particle: Particle, best: Particle, phi1: float, phi2: float
    ) -> Particle:
        u1 = (random.uniform(0, phi1) for _ in range(len(particle)))
        u2 = (random.uniform(0, phi2) for _ in range(len(particle)))

        v_u1 = map(
            operator.mul, u1, map(operator.sub, particle.best, particle)
        )
        v_u2 = map(operator.mul, u2, map(operator.sub, best, particle))

        particle.speed = list(
            map(operator.add, particle.speed, map(operator.add, v_u1, v_u2))
        )

        for i, speed in enumerate(particle.speed):
            if abs(speed) < particle.speed_min:
                particle.speed[i] = math.copysign(particle.speed_min, speed)
            elif abs(speed) > particle.speed_max:
                particle.speed[i] = math.copysign(particle.speed_max, speed)

        particle[:] = list(map(operator.add, particle, particle.speed))

        return particle

    def create_toolbox() -> base.Toolbox:
        toolbox = base.Toolbox()
        toolbox.register(
            "generate_particle",
            generate_particle,
            size=2,
            position_min=-6,
            position_max=6,
            speed_min=-3,
            speed_max=3
        )
        toolbox.register(
            "population", tools.initRepeat, list, toolbox.generate_particle
        )
        toolbox.register("update_particle", update_particle, phi1=2., phi2=2.)
        toolbox.register("evaluate", benchmarks.himmelblau)

        return toolbox

    # Create necessary objects
    # -1. in weights because we want to minimize a function
    creator.create("FitnessMin", base.Fitness, weights=(-1.,))
    creator.create(
        "Particle",
        list,
        fitness=creator.FitnessMin,
        speed=list,
        speed_min=None,
        speed_max=None,
        best=None
    )

    toolbox = create_toolbox()
    population: List[Particle] = toolbox.population(n=5)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean)
    stats.register("std", np.std)
    stats.register("min", np.min)
    stats.register("max", np.max)

    logbook = tools.Logbook()
    logbook.header = ["gen", "evals"] + stats.fields

    GEN = 1000
    best: Optional[Particle] = None

    for g in range(GEN):
        for particle in population:
            particle.fitness.values = toolbox.evaluate(particle)
            if not particle.best or particle.best.fitness < particle.fitness:
                particle.best = creator.Particle(particle)
                particle.best.fitness.values = particle.fitness.values
            if not best or best.fitness < particle.fitness:
                best = creator.Particle(particle)
                best.fitness.values = particle.fitness.values

        for particle in population:
            toolbox.update_particle(particle, best)

        logbook.record(gen=g, evals=len(population), **stats.compile(population))
        print(logbook.stream)

    if not best:
        raise Exception("Could not find best option")

    print("\n\n\n==================\n\n")
    print(population)
    print("\n==================\n\n")
    print(logbook)
    print("\n==================\n\n")
    print(best)
    print("\n==================")
